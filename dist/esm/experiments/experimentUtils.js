var e={d:(n,a)=>{for(var t in a)e.o(a,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:a[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n)},n={};e.d(n,{A:()=>s,u:()=>t});const a=(e,n,a)=>{if(!n)return console.warn("setNestedProperty called with an undefined or null path:",n),e;const t=n.split(".");let s=e;for(let e=0;e<t.length-1;e++){const n=t[e];s[n]||(s[n]=isNaN(t[e+1])?{}:[]),s=s[n]}const o=t[t.length-1];if(o.includes("[")&&o.includes("]")){const[e,t]=o.split(/\[(.+?)\]/).filter(Boolean);s[e]||(s[e]=[]);const r=parseInt(t,10);isNaN(r)?console.warn(`Invalid index in path: ${n}`):s[e][r]=a}else s[o]=a;return e};function t(e,n){const t={...n},s=(e,n="")=>{const o=n?`${n}.${e.mapsTo||""}`:e.mapsTo;if((e=>"group"===e.type)(e))e.items&&e.items.length>0?(Array.isArray(e.items)||console.warn(`Variable ${e.name} is a group but items is not an array.`),e.items.forEach((e=>{s(e,o)}))):console.warn(`Variable ${e.name} is a group but has no items.`);else if((r=o)&&r.includes("[")&&r.includes("]")){const[n,a]=o.split(/\[(.+?)\]/).filter(Boolean);t[n]||(t[n]=[]);const s=parseInt(a,10);if(isNaN(s))console.warn(`Variable ${e.name} has an invalid index in mapsTo property.`);else{t[n][s]||(t[n][s]={});const a=o.split(".").pop(),r="number"===e.type?Number(e.value):String(e.value);t[n][s][a]=r}}else if((e=>e&&e.includes("."))(o)){const n="number"===e.type?Number(e.value):String(e.value);a(t,o,n)}else if(o){const n="number"===e.type?Number(e.value):String(e.value);t[o]=n}else console.warn(`Variable ${e.name} does not have a valid mapsTo property.`);var r};return e.forEach((e=>s(e))),t}const s={variablesToConfigObject:t};var o=n.A,r=n.u;export{o as default,r as variablesToConfigObject};