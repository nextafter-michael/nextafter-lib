var e={d:(n,a)=>{for(var t in a)e.o(a,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:a[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n)},n={};e.d(n,{A:()=>s,K:()=>t});const a=(e,n,a)=>{if(!n)return console.warn("setNestedProperty called with an undefined or null path:",n),e;const t=n.split(".");let s=e;for(let e=0;e<t.length-1;e++){const n=t[e];s[n]||(s[n]=isNaN(t[e+1])?{}:[]),s=s[n]}const r=t[t.length-1];if(r.includes("[")&&r.includes("]")){const[e,t]=r.split(/\[(.+?)\]/).filter(Boolean);s[e]||(s[e]=[]);const o=parseInt(t,10);isNaN(o)?console.warn(`Invalid index in path: ${n}`):s[e][o]=a}else s[r]=a;return e};function t(e,n){const t={...n},s=(e,n="")=>{const r=n?`${n}.${e.mapsTo||""}`:e.mapsTo;if((e=>"group"===e.type)(e))e.items&&e.items.length>0?(Array.isArray(e.items)||console.warn(`Variable ${e.name} is a group but items is not an array.`),e.items.forEach((e=>{s(e,r)}))):console.warn(`Variable ${e.name} is a group but has no items.`);else if((o=r)&&o.includes("[")&&o.includes("]")){const[n,a]=r.split(/\[(.+?)\]/).filter(Boolean);t[n]||(t[n]=[]);const s=parseInt(a,10);if(isNaN(s))console.warn(`Variable ${e.name} has an invalid index in mapsTo property.`);else{t[n][s]||(t[n][s]={});const a=r.split(".").pop(),o="number"===e.type?Number(e.value):String(e.value);t[n][s][a]=o}}else if((e=>e&&e.includes("."))(r)){const n="number"===e.type?Number(e.value):String(e.value);a(t,r,n)}else if(r){const n="number"===e.type?Number(e.value):String(e.value);t[r]=n}else console.warn(`Variable ${e.name} does not have a valid mapsTo property.`);var o};return e.forEach((e=>{s(e)})),t}const s={handlebarsVariablesToConfigObject:t};var r=n.A,o=n.K;export{r as default,o as handlebarsVariablesToConfigObject};