var t={d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{A:()=>n});class i extends HTMLElement{static defaultOptions={typingSpeed:16,delayBetween:4,delayInitial:2,iterationCount:1/0};static CSS="\n        typing-text[typing] { position: relative }\n        typing-text[typing]:not(:has(::part(cursor)))::after::after {\n            content: '';\n            display: block;\n            position: absolute; right: -4px; bottom: -3px;\n            width: 2px;\n            height: 1.75em;\n            background-color: white;\n            transform: scaleY(0.65) translateY(1px);\n            animation: 1s ease-in-out 0s infinite running cursor-blink;\n        }\n        typing-text::part(cursor) {\n            display: inline-block;\n            line-height: 1.2;\n            width: 2px;\n            height: 1em;\n            background-color: white;\n            transform: scaleY(110%) translate(1px, 1px);\n        }\n        @keyframes cursor-blink {\n            0% { opacity: 1 }\n            50% { opacity: 0 }\n            100% { opacity: 1 }\n        }\n    ";static delay=t=>new Promise((e=>setTimeout(e,t)));static cursor=()=>{const t=document.createElement("i");return t.classList.add("cursor"),t.setAttribute("part","cursor"),t.animate([{opacity:1},{opacity:0},{opacity:1}],{duration:1e3,easing:"ease-in-out",iterations:1/0}),t};static async writeText(t){const e=t.nodeType===Node.ELEMENT_NODE;if(this.shadowRoot.innerHTML="",e){const e=t.cloneNode(!0),n=i.cursor();e.textContent="",this.shadowRoot.append(e),this.shadowRoot.append(n),e.setAttribute("cursor","typing"),t=t.textContent.trim();for(let n=0;n<t.length;n++)this.animationPaused?(await i.delay(100),n--):(e.textContent=e.textContent+t[n],await i.delay(1e3/this.options.typingSpeed));return e.removeAttribute("cursor"),n.remove(),e}{const e=document.createTextNode("");e.nodeValue="",this.shadowRoot.append(e),t=t.nodeValue.trim();for(let n=0;n<t.length;n++)this.animationPaused?(await i.delay(100),n--):(e.nodeValue=e.nodeValue+t[n],await i.delay(1e3/this.options.typingSpeed));return e}}static async deleteText(){if(this.shadowRoot.firstChild.nodeType===Node.ELEMENT_NODE){const t=this.shadowRoot.firstChild,e=i.cursor();for(this.shadowRoot.append(e),t.setAttribute("cursor","typing");t.textContent.length>0;)this.animationPaused?await i.delay(100):(t.textContent=t.textContent.slice(0,-1),await i.delay(1e3/this.options.typingSpeed));t.removeAttribute("cursor"),e.remove()}else{const t=this.shadowRoot.firstChild;for(;t.nodeValue.length>0;)this.animationPaused?await i.delay(100):(t.nodeValue=t.nodeValue.slice(0,-1),await i.delay(1e3/this.options.typingSpeed))}}constructor(){super(),this.attachShadow({mode:"open"}),this.slots=new Array,this.options={...i.defaultOptions};const t=this.attributes;for(let{name:e,value:i}of t)switch(Number.isNaN(parseFloat(i))||(i=parseFloat(i)%1==0?parseInt(i):parseFloat(i)),e){case"typing-speed":this.options.typingSpeed=i;break;case"delay-between":this.options.delayBetween=i;break;case"delay-initial":this.options.delayInitial=i;break;case"iteration-count":this.options.interationCount=i;break;default:this.options[e]=i}return 0==this.shadowRoot.ownerDocument.querySelectorAll('style[name="TypingText"]').length&&this.ownerDocument.head.insertAdjacentHTML("beforeend",`<style name="TypingText" type="text/css">${i.CSS}</style>`),window.addEventListener("blur",(()=>this.pauseAnimation())),window.addEventListener("focus",(()=>this.resumeAnimation())),this}connectedCallback(){Array.from(this.childNodes).forEach(((t,e)=>{switch(t.nodeType){case Node.TEXT_NODE:t.nodeValue.trim().length>0&&this.addSlot(t);break;case Node.ELEMENT_NODE:if(t.matches("br")||t.matches("hr")||t.matches("input")){console.warn("Element that cannot contain text nodes or other elements will be ignored:",t),t.remove();break}this.addSlot(t)}})),this.startAnimation()}addSlot(t){this.shadowRoot.append(t),this.slots.push(t)}removeSlot(t){(this.slots.includes(t)||-1!==this.slots.indexOf(t))&&(this.slots=this.slots.splice(this.slots.indexOf(t),1)),this.shadowRoot.contains(t)&&t.remove()}addSlots(...t){t.forEach((t=>this.addSlot(t)))}removeSlots(...t){t.forEach((t=>this.removeSlot(t)))}addText(t){const e=document.createTextNode(t);this.addSlot(e)}removeText(t){const e=this.slots.find((e=>e.nodeValue=t||e.match(t)));e&&this.removeSlot(e)}async startAnimation(){this.animationIndex=0;let t=0;const e=this.slots[this.animationIndex++].cloneNode(!0);if(this.shadowRoot.innerHTML="",this.shadowRoot.append(e),0===this.options.iterationCount)return this.pauseAnimation();for(await i.delay(1e3*this.options.delayInitial);this.options.iterationCount===1/0||t<this.options.iterationCount;){if(this.animationPaused){await i.delay(100);continue}if(0===this.slots.length){console.warn("<typing-text>","No text to animate.\n",this);break}const e=this.slots[this.animationIndex];this.setAttribute("typing",""),await i.deleteText.call(this),await i.writeText.call(this,e),this.removeAttribute("typing"),this.animationIndex=(this.animationIndex+1)%this.slots.length,0===this.animationIndex&&t++,await i.delay(1e3*this.options.delayBetween)}}pauseAnimation(){this.animationPaused=!0}resumeAnimation(){this.animationPaused=!1,this.startAnimation()}}const n=i;var o=e.A;export{o as default};